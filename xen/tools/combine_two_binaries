#!/usr/bin/env python3

import argparse
import re
import struct
import sys

parser = argparse.ArgumentParser(description='Generate assembly file to merge into other code.')
parser.add_argument('--script', dest='script',
                    required=True,
                    help='Linker script for extracting symbols')
parser.add_argument('--bin1', dest='bin1',
                    required=True,
                    help='First binary')
parser.add_argument('--bin2', dest='bin2',
                    required=True,
                    help='Second binary')
parser.add_argument('--output', dest='output',
                    help='Output file')
parser.add_argument('--map', dest='mapfile',
                    help='Map file to read for symbols to export')
parser.add_argument('--exports', dest='exports',
                    help='Symbols to export')
parser.add_argument('--section-header', dest='section_header',
                    default='.text',
                    help='Section header declaration')
args = parser.parse_args()

gap = 0x010200
text_diff = 0x408020

# Parse linker script for external symbols to use.
symbol_re = re.compile(r'\s+(\S+)\s*=\s*\.\s*\+\s*\((\d+)\s*\*\s*0\s*\)\s*;')
symbols = {}
lines = {}
for line in open(args.script):
    m = symbol_re.match(line)
    if not m:
        continue
    (name, line) = (m.group(1), int(m.group(2)))
    if line == 0:
        raise Exception(f"Invalid line number found:\n\t{line}")
    if line in symbols:
        raise Exception(f"Symbol with this line already present:\n\t{line}")
    if name in lines:
        raise Exception(f"Symbol with this name already present:\n\t{name}")
    symbols[line] = name
    lines[name] = line

exports = []
if args.exports is not None:
    exports = dict([(name, None) for name in args.exports.split(',')])

# Parse mapfile, look for ther symbols we want to export.
if args.mapfile is not None:
    symbol_re = re.compile(r'\s{15,}0x([0-9a-f]+)\s+(\S+)\n')
    for line in open(args.mapfile):
        m = symbol_re.match(line)
        if not m or m.group(2) not in exports:
            continue
        addr = int(m.group(1), 16)
        exports[m.group(2)] = addr
for (name, addr) in exports.items():
    if addr is None:
        raise Exception(f"Required export symbols {name} not found")

file1 = open(args.bin1, 'rb')
file2 = open(args.bin2, 'rb')
size1 = file1.seek(0, 2)
size2 = file2.seek(0, 2)
if size1 > size2:
    file1, file2 = file2, file1
    size1, size2 = size2, size1
if size2 != size1 + gap:
    raise Exception('File sizes do not match')

file1.seek(0, 0)
data1 = file1.read(size1)
file2.seek(gap, 0)
data2 = file2.read(size1)

max_line = max(symbols.keys())

i = 0
references = {}
internals = 0
while i <= size1 - 4:
    n1 = struct.unpack('<I', data1[i:i+4])[0]
    n2 = struct.unpack('<I', data2[i:i+4])[0]
    i += 1
    # The two numbers are the same, no problems
    if n1 == n2:
        continue
    # Try to understand why they are different
    diff = n1 - n2
    if diff == -gap: # this is an internal relocation
        pos = i - 1
        print(f"Internal relocation found at position {pos:#x} "
              f"n1={n1:#x} n2={n2:#x} diff={diff:#x}", file=sys.stderr)
        i += 3
        internals += 1
        if internals >= 10:
            break
        continue
    # This is a relative relocation to a symbol, accepted, code/data is
    # relocatable.
    if diff < gap and diff >= gap - max_line:
        n = gap - diff
        symbol = symbols.get(n)
        # check we have a symbol
        if symbol is None:
            raise Exception(f"Cannot find symbol for line {n}")
        pos = i - 1
        print(f'Position {pos:#x} {n} {symbol}', file=sys.stderr)
        i += 3
        references[pos] = symbol
        continue
    # First byte is the same, move to next byte
    if diff & 0xff == 0 and i <= size1 - 4:
       continue
    # Probably a type of relocation we don't want or support
    pos = i - 1
    suggestion = ''
    symbol = symbols.get(-diff - text_diff)
    if symbol is not None:
        suggestion = f" Maybe {symbol} is not defined as hidden?"
    raise Exception(f"Unexpected difference found at {i:#x} "
                    f"n1={n1:#x} n2={n2:#x} diff={diff:#x}.{suggestion}")
if internals != 0:
    raise Exception("Previous relocations found")

def line_bytes(buf, out):
    '''Output an assembly line with all bytes in "buf"'''
    print("\t.byte " + ','.join([str(n) for n in buf]), file=out)

def part(start, end, out):
    '''Output bytes of "data" from "start" to "end"'''
    while start < end:
        e = min(start + 16, end)
        line_bytes(data1[start:e], out)
        start = e

def reference(pos, out):
    name = references[pos]
    n = struct.unpack('<I', data1[pos:pos+4])[0]
    sign = '+'
    if n >= (1 << 31):
        n -= (1 << 32)
    n += pos
    if n < 0:
        n = -n
        sign = '-'
    print(f"\t.hidden {name}\n\t.long {name} {sign} {n:#x} - .", file=out)

def output(out):
    prev = 0
    exports_by_addr = {}
    for (sym, addr) in exports.items():
        exports_by_addr.setdefault(addr, []).append(sym)
    positions = list(references.keys())
    positions += list(exports_by_addr.keys())
    for pos in sorted(positions):
        part(prev, pos, out)
        prev = pos
        if pos in references:
            reference(pos, out)
            prev = pos + 4
        if pos in exports_by_addr:
            for sym in exports_by_addr[pos]:
                print(f"\t.global {sym}\n\t.hidden {sym}\n{sym}:", file=out)
    part(prev, size1, out)

out = sys.stdout
if args.output is not None:
    out = open(args.output, 'w')
print(f'\t{args.section_header}', file=out)
output(out)
print('\n\t.section\t.note.GNU-stack,"",@progbits', file=out)
out.flush()
